#     .x = names(param_codes),
#     .f = function(df, var_name) {
#       df %>% filter(!!sym(var_name) %in% unlist(param_codes[[var_name]]))
#     },
#     .init = data_db
#   )
# }
#
if (length(param_codes) > 0) {
for (var_name in names(param_codes)) {
if (!(var_name %in% col_names)) {
stop(paste("Parámetro", var_name, "no es una columna válida."))
}
values <- unlist(param_codes[[var_name]])
data_db <- data_db %>% filter(.data[[var_name]] %in% values)
}
}
filtered_data <- collect(data_db)
user_id <- Sys.info()["user"]
unique_id <- UUIDgenerate()
final_db_path <- paste0("data/", user_id, "_", unique_id, "_filtered_data.duckdb")
dir.create(dirname(final_db_path), recursive = TRUE, showWarnings = FALSE)
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = final_db_path)
DBI::dbWriteTable(con, "filtered_table", filtered_data, overwrite = TRUE)
filtered_data_check <- DBI::dbReadTable(con, "filtered_table")
print(head(filtered_data_check))
on.exit(
{
try(DBI::dbDisconnect(con), silent = TRUE)
},
add = TRUE
)
on.exit(
{
try(spod_disconnect(data_db), silent = TRUE)
try(gc(), silent = TRUE)
try(unlink(temp_dir, recursive = TRUE), silent = TRUE)
},
add = TRUE
)
return(list(status = "success", db_path = final_db_path))
},
error = function(e) {
return(list(status = "error", message = e$message))
}
)
}
# in-code test
result <- download_data_filtered_v2(
zones = "muni",
start_date = "2022-01-01",
end_date = "2022-01-02",
type = "od",
param_codes = list(
id_origin = c("01059", "02003", "03014"),
id_destination = c("02003", "03014")
)
)
result
download_data_filtered_v2 <- function(
zones, start_date, end_date,
type,
param_codes,
os_option = NULL,
max_download_size = 1) {
close_orphan_duckdb_process()
tryCatch(
{
temp_dir <- create_temp_dir()
print(temp_dir)
spod_set_data_dir(temp_dir)
db_path <- file.path(temp_dir, "raw_data.duckdb")
dates <- c(start = start_date, end = end_date)
db <- spod_convert(
type = type,
zones = zones,
dates = dates,
overwrite = TRUE
)
data_db <- spod_connect(db)
#data_db <- data_db %>% as.data.frame()
print(sapply(data_db, class))
col_names <- colnames(data_db)
# if (length(param_codes) > 0) {
#   for (var_name in names(param_codes)) {
#     if (!(var_name %in% col_names)) {
#       stop(paste("Parámetro", var_name, "no es una columna válida."))
#     }
#   }
#
#   data_db <- reduce(
#     .x = names(param_codes),
#     .f = function(df, var_name) {
#       df %>% filter(!!sym(var_name) %in% unlist(param_codes[[var_name]]))
#     },
#     .init = data_db
#   )
# }
#
if (length(param_codes) > 0) {
for (var_name in names(param_codes)) {
if (!(var_name %in% col_names)) {
stop(paste("Parámetro", var_name, "no es una columna válida."))
}
values <- unlist(param_codes[[var_name]])
data_db <- data_db %>% filter(.data[[var_name]] %in% values)
}
}
filtered_data <- collect(data_db)
user_id <- Sys.info()["user"]
unique_id <- UUIDgenerate()
final_db_path <- paste0("data/", user_id, "_", unique_id, "_filtered_data.duckdb")
dir.create(dirname(final_db_path), recursive = TRUE, showWarnings = FALSE)
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = final_db_path)
DBI::dbWriteTable(con, "filtered_table", filtered_data, overwrite = TRUE)
filtered_data_check <- DBI::dbReadTable(con, "filtered_table")
print(head(filtered_data_check))
on.exit(
{
try(DBI::dbDisconnect(con), silent = TRUE)
},
add = TRUE
)
on.exit(
{
try(spod_disconnect(data_db), silent = TRUE)
try(gc(), silent = TRUE)
try(unlink(temp_dir, recursive = TRUE), silent = TRUE)
},
add = TRUE
)
return(list(status = "success", db_path = final_db_path))
},
error = function(e) {
return(list(status = "error", message = e$message))
}
)
}
result <- download_data_filtered_v2(
zones = "muni",
start_date = "2022-01-01",
end_date = "2022-01-02",
type = "od",
param_codes = list(
id_origin = c("01059", "02003", "03014"),
id_destination = c("02003", "03014")
)
)
result
download_data_filtered_v2 <- function(
zones, start_date, end_date,
type,
param_codes,
os_option = NULL,
max_download_size = 1) {
close_orphan_duckdb_process()
tryCatch(
{
temp_dir <- create_temp_dir()
print(temp_dir)
spod_set_data_dir(temp_dir)
db_path <- file.path(temp_dir, "raw_data.duckdb")
dates <- c(start = start_date, end = end_date)
db <- spod_convert(
type = type,
zones = zones,
dates = dates,
overwrite = TRUE
)
data_db <- spod_connect(db)
data_db <- data_db %>% as.data.frame()
print(sapply(data_db, class))
col_names <- colnames(data_db)
# if (length(param_codes) > 0) {
#   for (var_name in names(param_codes)) {
#     if (!(var_name %in% col_names)) {
#       stop(paste("Parámetro", var_name, "no es una columna válida."))
#     }
#   }
#
#   data_db <- reduce(
#     .x = names(param_codes),
#     .f = function(df, var_name) {
#       df %>% filter(!!sym(var_name) %in% unlist(param_codes[[var_name]]))
#     },
#     .init = data_db
#   )
# }
#
if (length(param_codes) > 0) {
for (var_name in names(param_codes)) {
if (!(var_name %in% col_names)) {
stop(paste("Parámetro", var_name, "no es una columna válida."))
}
}
filter_exprs <- map2(
names(param_codes),
param_codes,
~ expr(.data[[!!.x]] %in% !!.y)
)
data_db <- data_db %>% filter(!!!filter_exprs)
}
filtered_data <- collect(data_db)
user_id <- Sys.info()["user"]
unique_id <- UUIDgenerate()
final_db_path <- paste0("data/", user_id, "_", unique_id, "_filtered_data.duckdb")
dir.create(dirname(final_db_path), recursive = TRUE, showWarnings = FALSE)
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = final_db_path)
DBI::dbWriteTable(con, "filtered_table", filtered_data, overwrite = TRUE)
filtered_data_check <- DBI::dbReadTable(con, "filtered_table")
print(head(filtered_data_check))
on.exit(
{
try(DBI::dbDisconnect(con), silent = TRUE)
},
add = TRUE
)
on.exit(
{
try(spod_disconnect(data_db), silent = TRUE)
try(gc(), silent = TRUE)
try(unlink(temp_dir, recursive = TRUE), silent = TRUE)
},
add = TRUE
)
return(list(status = "success", db_path = final_db_path))
},
error = function(e) {
return(list(status = "error", message = e$message))
}
)
}
result <- download_data_filtered_v2(
zones = "muni",
start_date = "2022-01-01",
end_date = "2022-01-02",
type = "od",
param_codes = list(
id_origin = c("01059", "02003", "03014"),
id_destination = c("02003", "03014")
)
)
result
download_data_filtered_v2 <- function(
zones, start_date, end_date,
type,
param_codes,
os_option = NULL,
max_download_size = 1) {
close_orphan_duckdb_process()
tryCatch(
{
temp_dir <- create_temp_dir()
print(temp_dir)
spod_set_data_dir(temp_dir)
db_path <- file.path(temp_dir, "raw_data.duckdb")
dates <- c(start = start_date, end = end_date)
db <- spod_convert(
type = type,
zones = zones,
dates = dates,
overwrite = TRUE
)
data_db <- spod_connect(db)
data_db <- data_db %>% as.data.frame()
print(sapply(data_db, class))
col_names <- colnames(data_db)
# if (length(param_codes) > 0) {
#   for (var_name in names(param_codes)) {
#     if (!(var_name %in% col_names)) {
#       stop(paste("Parámetro", var_name, "no es una columna válida."))
#     }
#   }
#
#   data_db <- reduce(
#     .x = names(param_codes),
#     .f = function(df, var_name) {
#       df %>% filter(!!sym(var_name) %in% unlist(param_codes[[var_name]]))
#     },
#     .init = data_db
#   )
# }
#
if (length(param_codes) > 0) {
for (var_name in names(param_codes)) {
if (!(var_name %in% col_names)) {
stop(paste("Parámetro", var_name, "no es una columna válida."))
}
values <- unlist(param_codes[[var_name]])
data_db <- data_db[data_db[[var_name]] %in% values, ]
}
}
filtered_data <- collect(data_db)
user_id <- Sys.info()["user"]
unique_id <- UUIDgenerate()
final_db_path <- paste0("data/", user_id, "_", unique_id, "_filtered_data.duckdb")
dir.create(dirname(final_db_path), recursive = TRUE, showWarnings = FALSE)
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = final_db_path)
DBI::dbWriteTable(con, "filtered_table", filtered_data, overwrite = TRUE)
filtered_data_check <- DBI::dbReadTable(con, "filtered_table")
print(head(filtered_data_check))
on.exit(
{
try(DBI::dbDisconnect(con), silent = TRUE)
},
add = TRUE
)
on.exit(
{
try(spod_disconnect(data_db), silent = TRUE)
try(gc(), silent = TRUE)
try(unlink(temp_dir, recursive = TRUE), silent = TRUE)
},
add = TRUE
)
return(list(status = "success", db_path = final_db_path))
},
error = function(e) {
return(list(status = "error", message = e$message))
}
)
}
result <- download_data_filtered_v2(
zones = "muni",
start_date = "2022-01-01",
end_date = "2022-01-02",
type = "od",
param_codes = list(
id_origin = c("01059", "02003", "03014"),
id_destination = c("02003", "03014")
)
)
result
download_data_filtered_v2 <- function(
zones, start_date, end_date,
type,
param_codes,
os_option = NULL,
max_download_size = 1) {
close_orphan_duckdb_process()
tryCatch(
{
temp_dir <- create_temp_dir()
print(temp_dir)
spod_set_data_dir(temp_dir)
db_path <- file.path(temp_dir, "raw_data.duckdb")
dates <- c(start = start_date, end = end_date)
db <- spod_convert(
type = type,
zones = zones,
dates = dates,
overwrite = TRUE
)
data_db <- spod_connect(db)
data_db <- data_db %>% as.data.frame()
print(sapply(data_db, class))
col_names <- colnames(data_db)
# if (length(param_codes) > 0) {
#   for (var_name in names(param_codes)) {
#     if (!(var_name %in% col_names)) {
#       stop(paste("Parámetro", var_name, "no es una columna válida."))
#     }
#     values <- unlist(param_codes[[var_name]])
#     data_db <- data_db[data_db[[var_name]] %in% values, ]
#   }
# }
if (length(param_codes) > 0) {
# Primero, verifica que todas las columnas existen
for (var_name in names(param_codes)) {
if (!(var_name %in% col_names)) {
stop(paste("Parámetro", var_name, "no es una columna válida."))
}
}
# Creamos un vector lógico de la misma longitud que las filas de data_db
keep <- rep(FALSE, nrow(data_db))
for (var_name in names(param_codes)) {
values <- unlist(param_codes[[var_name]])
keep <- keep | (data_db[[var_name]] %in% values)
}
data_db <- data_db[keep, ]
}
filtered_data <- collect(data_db)
user_id <- Sys.info()["user"]
unique_id <- UUIDgenerate()
final_db_path <- paste0("data/", user_id, "_", unique_id, "_filtered_data.duckdb")
dir.create(dirname(final_db_path), recursive = TRUE, showWarnings = FALSE)
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = final_db_path)
DBI::dbWriteTable(con, "filtered_table", filtered_data, overwrite = TRUE)
filtered_data_check <- DBI::dbReadTable(con, "filtered_table")
print(head(filtered_data_check))
on.exit(
{
try(DBI::dbDisconnect(con), silent = TRUE)
},
add = TRUE
)
on.exit(
{
try(spod_disconnect(data_db), silent = TRUE)
try(gc(), silent = TRUE)
try(unlink(temp_dir, recursive = TRUE), silent = TRUE)
},
add = TRUE
)
return(list(status = "success", db_path = final_db_path))
},
error = function(e) {
return(list(status = "error", message = e$message))
}
)
}
result <- download_data_filtered_v2(
zones = "muni",
start_date = "2022-01-01",
end_date = "2022-01-02",
type = "od",
param_codes = list(
id_origin = c("01059", "02003", "03014"),
id_destination = c("02003", "03014")
)
)
result
close_orphan_duckdb_process()
download_data_filtered_v2 <- function(
zones, start_date, end_date,
type,
param_codes,
os_option = NULL,
max_download_size = 1) {
close_orphan_duckdb_process()
tryCatch(
{
temp_dir <- create_temp_dir()
print(temp_dir)
spod_set_data_dir(temp_dir)
db_path <- file.path(temp_dir, "raw_data.duckdb")
dates <- c(start = start_date, end = end_date)
db <- spod_convert(
type = type,
zones = zones,
dates = dates,
overwrite = TRUE
)
data_db <- spod_connect(db)
data_db <- data_db %>% as.data.frame()
print(sapply(data_db, class))
col_names <- colnames(data_db)
# if (length(param_codes) > 0) {
#   for (var_name in names(param_codes)) {
#     if (!(var_name %in% col_names)) {
#       stop(paste("Parámetro", var_name, "no es una columna válida."))
#     }
#     values <- unlist(param_codes[[var_name]])
#     data_db <- data_db[data_db[[var_name]] %in% values, ]
#   }
# }
if (length(param_codes) > 0) {
# Primero, verifica que todas las columnas existen
for (var_name in names(param_codes)) {
if (!(var_name %in% col_names)) {
stop(paste("Parámetro", var_name, "no es una columna válida."))
}
}
# Creamos un vector lógico de la misma longitud que las filas de data_db
keep <- rep(FALSE, nrow(data_db))
for (var_name in names(param_codes)) {
values <- unlist(param_codes[[var_name]])
keep <- keep | (data_db[[var_name]] %in% values)
}
data_db <- data_db[keep, ]
}
filtered_data <- collect(data_db)
user_id <- Sys.info()["user"]
unique_id <- UUIDgenerate()
final_db_path <- paste0("data/", user_id, "_", unique_id, "_filtered_data.duckdb")
dir.create(dirname(final_db_path), recursive = TRUE, showWarnings = FALSE)
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = final_db_path)
DBI::dbWriteTable(con, "filtered_table", filtered_data, overwrite = TRUE)
filtered_data_check <- DBI::dbReadTable(con, "filtered_table")
print(head(filtered_data_check))
on.exit(
{
try(DBI::dbDisconnect(con), silent = TRUE)
},
add = TRUE
)
on.exit(
{
try(spod_disconnect(data_db), silent = TRUE)
try(gc(), silent = TRUE)
try(unlink(temp_dir, recursive = TRUE), silent = TRUE)
},
add = TRUE
)
return(list(status = "success", db_path = final_db_path))
},
error = function(e) {
return(list(status = "error", message = e$message))
}
)
}
result <- download_data_filtered_v2(
zones = "muni",
start_date = "2022-01-01",
end_date = "2022-01-02",
type = "od",
param_codes = list(
id_origin = c("01059", "02003", "03014"),
id_destination = c("02003", "03014")
)
)
result
